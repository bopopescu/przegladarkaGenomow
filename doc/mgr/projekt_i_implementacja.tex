\chapter{Projekt i implementacja}


\section{Architektura}

Przeglądarka została zaimplementowana w wielowarstwowej architekturze klient-serwer.
Kod został podzielony na moduły, aby jak najbardziej oddzielić od siebie niezależne fragmenty aplikacji zachowując przy tym dobre praktyki programistyczne.
Rozróżniamy w pracy 3 główne warstwy odpowiadające za:
\begin{itemize}
	\item prezentację
	\item obsługę danych
	\item logikę biznesową
\end{itemize}

\subsection*{BioWeb}

BioWeb jest środowiskiem aplikacyjnym, w którym zostało stworzonych wiele aplikacji przetwarzających dane genetyczne \cite{article:bioweb}.
Programy operujące na obszernych zbiorach genetycznych wymagają architektury zapewniającej m.in. przenośność, elastyczność i wysoką wydajność nie rezygnując jednocześnie z interaktywnego interfejsu użytkownika.
Zaspokojenie ww. wymagań możliwe jest dzięki połączeniu ze sobą w jednym projekcie języków kompilowanych i interpretowanych.
Zastosowanie architektury BioWeb przyspiesza sam proces wytwarzania oprogramowania poprzez podejście zalecające implementację jedynie modułów obliczeniowych w językach niskiego poziomu (C++), natomiast część serwerową i kliencką, które nie są wąskimi gardłami, w językach interpretowanych takich jak Python i Javascript.
Innymi słowy - moduły nie wymagające ponad przeciętnej wydajności, które można stworzyć szybciej, implementowane są w językach wyższego poziomu a moduły zasobożerne są w językach niskiego poziomu. Odpowiedni dobór konkretnych technologii dał możliwość wygodnego połączenia ww. technik.
Na rysunku \todo{[link]} zamieszony został schemat struktury aplikacji.
\\
\todo{[rysunek schematu - trójwarstwowa aplikacja ze schematem technologii.]}


\subsection*{Klient, warstwa prezentacji}
Moduł klienta znajdujący się w warstwie prezentacji możemy zaliczyć do grupy klientów cienkich.
Odpowiada on za ilustrowanie danych pobranych z serwera wykonując operacje renderowania elementów graficznych oraz zapewnia interaktywną komunikację użytkownika z systemem.
W obecnych czasach, praktycznie każdy komputer stacjonarny a nawet urządzenia mobilne posiadają stosunkowo dużą moc obliczeniową pozwalającą na proste przetwarzanie.
Realizując projekt, zastosowano podejście, w którym odpowiedzialność za operacje takie jak walidacja danych, generowanie rysunków czy animacje pozostają na barkach modułu klienckiego. 
Tym samym, odciążony zostaje serwer, przez co podwyższamy jego możliwości wydajnościowe co sprowadza się do zwiększenia potencjalnej liczby jednocześnie obsługiwanych użytkowników.

Do implementacji warstwy prezentacji zostały użyte technologie webowe, wykorzystujące jako środowisko uruchomieniowe przeglądarkę internetową. Użytkownikowi wystarczy jedynie maszyna z dostępem do internetu i nowoczesną przeglądarką internetową wpierająca HTML5. 
Klient może być uruchomiony na dowolnym popularnym systemie operacyjnym \mbox{(Linux/Mac/Windows)} i zwolniony jest z potrzeby aktualizowania aplikacji - wszystkie moduły ładowane są podczas inicjacji przeglądarki genomu.

\subsection*{Serwer - warstwa trwałości i przetwarzania}
Serwer jest przenośny, wykorzystuje technologie dające się uruchomić na najpopularniejszych platformach komputerowych - Unix, Windows.
System pozwala na równoległą obsługę wielu użytkowników jednocześnie.
W celu zwiększenia wydajności aplikacja daje się stosunkowo łatwo skalować horyzontalnie i wertykalnie.
Wpływ na szybkość przetwarzania żądań, głównie ma klasa zastosowanego sprzętu komputerowego.
Jego główne zadania to gromadzenie danych, udostępnienie ich dla aplikacji klienckiej poprzez API, przechowywanie stanu przeglądarki, wykonywanie zadań przeszukiwania genomu.

\section{Wykorzystane technologie}
Python jest głównym językiem programowania używanym w przeglądarce.
Jest interpretowany, wspiera wiele paradygmatów programowania, uważany jest jako prosty do nauki, posiada rozbudowaną bibliotekę standardową i jest mocno wspierany przez społeczność. 
Aplikacje pisane w nim są przenośne i szybkie zarazem, ponieważ wiele bibliotek pod spodem jest zaimplementowanych w C/C++.

Algorytmy do wyszukiwania sekwencji, zostały zaimplementowane w języku C++ i zintegrowane z częścią serwerową za pomocą biblioteki \textit{BoostPython}.
Biblioteka ta stworzona została aby szybko i łatwo eksportować C++ do Pythona.
Jest tak zaprojektowana, aby była minimalnie inwazyjna dla kodu C++ - w większości przypadków nie ma konieczności w żaden sposób zmieniać klas C++ aby używać ich z \textit{BoostPython}.

Aby uprościć standardowe czynności związane z pisaniem aplikacji webowej wykorzystany został popularny framework pythonowy - Django. 
Automatyzuje on wiele zadań związanych z obsługą żądań HTTP (Django REST Framework), dostarcza panel administracyjny, system cache'owania, serwer do testowania aplikacji i wiele innych.
Kluczową dostarczoną funkcjonalnością jest maper obiektowo relacyjny ORM\footnote{ang. Object Relational Mapping.}, który w wygodny sposób daje nam dostęp do danych zgromadzonych w bazie danych bez potrzeby pisania niekiedy skomplikowanych zapytań SQL.
Jako system bazodanowy użyty został PostgreSQL - jeden z najpopularniejszych systemów relacyjnych o otwartym kodzie źródłowym.

Jako serwer WWW wykorzystany został Nginx, który z Django łączy się za pośrednictwem serwera HTTP Gunicorn implementującego interfejs WSGI\footnote{ang. Web Server Gateway Interface.}.

Podstawą części wizualizacyjnej, dostarczającej graficzny interfejs użytkownika (GUI\footnote{ang. Graphical User Interface}) jest język HTML5 wraz z JavaScriptem.
Element ,,canvas'' pozwala na dynamiczne, skryptowe renderowanie kształtów i obrazów bitmapowych bez dodatkowych wtyczek - został użyty do odrysowywania głównego widoku mapy genomu.
Aby ułatwić zadania towarzyszące tworzeniu aplikacji w modelu SPA\footnote{ang. Single Page Application}, wykorzystany został framework \textit{AngularJS} oparty o wzorzec projektowy MVC\footnote{ang. Model View Controller}.
Angular jest otwartoźródłowym projektem wydanym i rozwijanym przez firmę \textit{Google}.
Bardzo pomocny przy implementacji wartwy prezentacji okazał się również framework CSS\footnote{ang. Cascading Style Sheets} \textit{Bootstrap}, który ułatwił stylizację komponentów wyświetlanych na stronie.

Fragmenty kodu odpowiedzialne za budowanie aplikacji, uruchamianie jej w różnych konfiguracjach, kompilację modułów obliczeniowych itp. wykorzystują narzędzie \textit{SCons}.
Pliki konfiguracyjne mają formę skryptów pythonowych, natomiast sama funkcjonalność narzędzia pod wieloma względami przypomina tradycyjny program powłoki systemowej, automatyzujący np. proces kompilacji programów - \textit{GNU make}.

\begin{figure}[h]
	\centering
	\includegraphics[width=1\textwidth]{img/loga.png}
	\caption{Technologie wykorzystane w projekcie.}
	\vspace{-0.5cm}
	\label{img:technologie}
\end{figure}


\section{Struktura projektu}
\todo{todo: obrazek z drzewem projektu\\}
W niniejszym rozdziale przybliżę strukturę plików i folderów w projekcie oraz wyszczególnię ważniejsze fragmenty kodu.
Zaimplementowana aplikacja została podzielona na następujące moduły:

\subsection*{build\_tools}
Zawiera klasy wykorzystywane do budowania aplikacji, pliki konfiguracyjne:


\begin{itemize}
	\item \textit{requirements.txt} - spis bibliotek pythonowych, które zostaną zainstalowane w wyizolowanym środowisku \textit{virtualenv}.
	\todo{todo: dodać link do opisu pliku SCons}
	
	\item \textit{deploy\_conf\_files} - folder zawierający szablon pliku konfiguracyjnego serwera www \textit{nginx}, wykorzystywany przy produkcyjnym budowaniu aplikacji.
	\todo{todo: dodać link do opisu pliku SCons}
	
	\item \textit{build.AppBuilder} - klasa umożliwiająca zarządzanie plikiem konfigurującym proces budowania, tworzenie struktury folderów projektu, utworzenie środowiska \textit{virtualenv} wraz z pobraniem i zainstalowaniem niezbędnych bibliotek pythonowych, pobranie i wypakowanie plików zawierających dane dotyczące genomu ogórka, które wykorzystywane są podczas inicjacji bazy danych.
	
	\item \textit{deploy.Deployer} - klasa pozwalająca renderować plik konfiguracyjny serwera www \textit{nginx}, generować sekretny klucz \textit{Django}, konfigurować ustawienie \textit{Django ALLOWED\_HOSTS} niezbędne do prawidłowego działania serwera.
\end{itemize}

\subsection*{functional\_tests}
Zawiera sterownik do silnika przeglądarki \textit{Chrome} oraz testy funkcjonalne wykorzystujące bibliotekę do testowania webowych aplikacji - \textit{Selenium}.

\subsection*{zpr}
Zawiera główne ustawienia \textit{Django} (settings.py) oraz korzeń API HTTP aplikacji (urls.py).

\subsection*{zpr/database}
Zawiera skrypty służące do parsowania danych biologicznych pozyskanych od SGGW, narzędzia do obrabiania tych danych, tj. ekstrahowania informacji, przygotowywania struktur pomocniczych, grupowania, filtrowania, zliczania, sortowania oraz finalnie - generowania ciągów chromosomów po odrzuceniu błędnych, niespójnych danych.

\subsection*{zprapp}
Główny folder aplikacji, zawiera moduły logiki i prezentacji.
Bezpośrednio w folderze znajdują się m.in. pliki widoków API, serializerów, trasowania url, panelu administracyjnego, schematu bazy danych, testów jednostkowych.

\subsection*{zprapp/calc}
Zawiera algorytmy wyszukiwania podciągów zaimplementowane w języku \textit{C++}: \textit{Knutha-Morrisa-Pratta}, \textit{Boyera-Moore'a}, \textit{Smitha-Watermana}, \textit{BLAST} oraz ich interfejsy pozwalające na wywołanie kodu bezpośrednio z poziomu \textit{Pythona}. Algorytmy zostały zaimplementowane przez \textit{Piotra Róża}.

\subsection*{zprapp/templates/zprapp}
Zawiera pliki HTML dynamicznie renderowane w przeglądarce internetowej podczas użytkowania aplikacji.

\subsection*{zprapp/static/zprapp}
Zawiera biblioteki Javascriptowe wraz ze stylami CSS wykorzystywane po stronie frontendu.
Tutaj została zaimplementowana większość kodu kontrolerów Angularowych.
W folderze \textit{lang} obecne są również pliki zawierające tłumaczenia słów w dwóch językach - angielskim i polskim.
Aplikację w prosty, nieinwazyjny sposób można rozszerzyć o więcej języków.

\subsection*{zprapp/contrib}
Lokalizacja zawierają funkcje i klasy wykorzystywane m.in. do pomiarów i porównania szybkości algorytmów oraz łączenia ciągów podsekwencji w dłuższe fragmenty.


\section{Baza danych}
\todo{todo}
Na rysunku \ref{img:db_model} został przedstawiony schemat bazy danych.
\begin{figure}[h]
	\centering
	\includegraphics[width=1\textwidth]{img/db_model.png}
	\caption{Schemat bazy danych przeglądarki CuGene.}
	\label{img:db_model}
\end{figure}


\section{Algorytmy}
Aplikacja oferuje funkcjonalność pozwalającą na wyszukiwanie sekwencji podobnych w zadanych podciągach nukleotydowych.
Celem jest określenie faktu pochodzenia genów od wspólnego, ewolucyjnego przodka.
Ważnym staję się pojęcie \textit{homologii} i jego nawiązanie do pokrewnego terminu jakim jest \textit{podobieństwo}.
Różnią się tym, że homologia jest pojęciem jakościowym, którego stopień może być stwierdzony przy pewnym poziomie podobieństwa sekwencji.
Poziom ten nie jest jednoznacznie ustalony i zależy od wielu czynników w szczególności - długości porównywanych sekwencji.
Do stwierdzenia homologii potrzebna jest fachowa interpretacja wyników wykonana przez biologów.

Genom może podlegać zmianom takim jak substytucja, delecja czy insercja.
Możliwe jest, że dywergencje genomowe są na tyle duże, iż nie da się stwierdzić wspólnego powiązania ewolucyjnego dwóch sekwencji.
Przy krótkich sekwencjach nawet dość duże dopasowanie nie koniecznie musi świadczyć o relacji homologiczności, albowiem istnieje wtedy wysokie prawdopodobieństwo, że zaszło przypadkowe dopasowanie, ponieważ sekwencje kwasu deoksyrybonukleinowego są wariacją zbioru 4 elementowego. W DNA rozróżniamy 4 zasady azotowe - adeninę, cytozynę, guaninę oraz tyminę, które reprezentowane są odpowiednio poprzez symbole A,C,G i T.

Dane, ze względu na swój genomowy charakter, należy porównywać w inny sposób niż poprzez zwykłe sprawdzenie procentowego pokrycia jednej sekwencji w drugiej.
Algorytmy wyszukiwania sekwencji podobnych dzielą się na:
\begin{itemize}
	\item algorytmy programowania dynamicznego
	\item algorytmy heurystyczne
\end{itemize}


\subsection*{Smith-Waterman}
Reprezentantem pierwszej grupy algorytmów jest algorytm Smitha-Waterman'a.
Cechuje się tym, że znajduje dość krótkie, ale za to bardzo podobne odcinki sekwencji.
Jest metodą badawczą należącą do gromady technik wyczerpujących - analizuje wszystkie potencjalne rozwiązania w celu wybrania tego, które spełnia najlepiej warunki zadania.
Ze względu na dużą złożoność pamięciową i obliczeniową nie może być stosowany uniwersalnie do każdego zadania, ale ponieważ ma wysoką czułość to jest chętnie wykorzystywany przez biologów w wielu zastosowaniach.

Jego zasada działania polega na jednoczesnym o budowaniu i analizie dwuwymiarowej tablicy przyrównania. Porównuje on reszty sekwencji we wszystkich możliwych kombinacjach podsekwencji zadanych ciągów, oceniając ich dopasowanie według przyjętego wzoru.
Rozpatrywane ciągi umieszczamy wzdłuż prostopadłych krawędzi macierzy, a sama analiza odbywa się wierszami.
Każda reszta podciągu pierwszej sekwencji jest oceniana ze wszystkimi resztami podciągów drugiej sekwencji, a ocena jest wpisywana do macierzy.
Wartość oceny jest ustalana na podstawie dopasowania 3 sąsiadujących, ocenionych już komórek - lewej, górnej i skośnej.
W stworzonej przeglądarce, ocena komórki $H(i,j)$ określona jest wzorem \ref{wzor:ocena_komorki_smith_waterman}.
\begin{equation}
\label{wzor:ocena_komorki_smith_waterman}
H(i,j) = max \left\{ 
	\begin{array}{ll}
		H(i-1,j-1) + s(a_i, b_j) & \textrm{po skosie}\\
		H(i-1,j) - W(l) & \textrm{nad}\\
		H(i, j-1) -W(l)& \textrm{po lewej}\\
		0 &
	\end{array}
	\right.
\end{equation}
gdzie $W(l)$ to funkcja kary od długości przerwy, $s(a_i, b_j)$ to funkcja dopasowania komórek na współrzędnych $a_j, b_j$.

Gdy macierz będzie już cała uzupełniona, odnajdujemy komórkę o największej wartości i cofając się po ścieżce wyznaczamy wynikowy ciąg.

Przy założeniach \ref{wzor:zalozenia_smith_waterman}, ciągach \verb|TGTTACGG| oraz \verb|GGTTGACTA|, wyznaczona macierz wyglądałaby jak na ilustracji \ref{img:Smith-Waterman-kroki-2-3}
\begin{equation}
\label{wzor:zalozenia_smith_waterman}
s(a_i,a_j) =\left\{ 
	\begin{array}{ll}
	3 & \textrm{$a_i = a_j$}\\
	-3 & \textrm{$a_i \ne a_j$}\\
\end{array}\\
\right.\\
{\phantom{1}}
W(l) = 2l, W_1 = 2
\end{equation}

\begin{figure}[h]
	\centering
	\includegraphics[width=1\textwidth]{img/Smith-Waterman-Algorithm-Example-Step2-and-3.png}
	\caption{Macierz oceny Smitha-Watermana przykładowych ciągów.}
	\label{img:Smith-Waterman-kroki-2-3}
	\vspace{-0.5cm}
	\caption*{\scriptsize Źródło: 
		\url{https://en.wikipedia.org/wiki/Smith-Waterman\_algorithm}
	}
\end{figure}

\subsection*{BLAST}
\todo{todo}

\subsection*{KMP}
\todo{todo}

\subsection*{BM}
\todo{todo}




\section{Sekwencje ogórka}

\section{Interfejs użytkownika}

\section{Instrukcja uruchomienia aplikacji}
W celu zautomatyzowania budowy, kompilacji oraz konfiguracji aplikacji zostało wykorzystane narzędzie \textit{Scons}.
Aby zbudować i uruchomić część serwerową przeglądarki genomów w środowisku Linux z rodziny \textit{Debian}, zaleca się wykonać następujące czynności:
\begin{enumerate}
	\item zainstalować bazę danych \textit{PostgreSQL} w wersji 9.5
	\item zainstalować język Python w wersji 2.7 wraz menadżerem paczek \textit{pip} i środowiskiem virtualenv
	\item zainstalować bibliotekę \textit{Boost} w wersji 1.64
\end{enumerate}
Powyższe zadania można wykonać poleceniami:

\begin{spverbatim}
	apt-get install libpq-dev python-dev python-pip scons postgresql nginx
	pip2 install virtualenv
	tar --bzip2 -xf /path/to/boost_1_64_0.tar.bz2 ./bootstrap.sh --with-python=python ./b2 install
\end{spverbatim}

\begin{enumerate}[resume]
	\item utworzyć użytkownika \textit{zpr} o haśle \textit{zpr}
	\item utworzyć bazy danych \textit{zpr} oraz \textit{ogorek\_roboczy}
\end{enumerate}
Powyższe zadania można wykonać poleceniami:

\begin{spverbatim}
	sudo -u postgres createuser --superuser --createdb --createrole zpr 
	sudo -u postgres psql -c "alter user zpr with encrypted password 'zpr';"
	sudo -u postgres createdb -O zpr zpr 
	sudo -u postgres createdb -O zpr ogorek_roboczy
\end{spverbatim}

\begin{enumerate}[resume]
	\item przetestować połączenie z bazą danych poleceniem\\
	\verb|psql zpr -U zpr|\\
	w przypadku pojawiającego się błędu\\
	\verb|psql: FATAL: Peer authentication failed for user "zpr""|
	należy w pliku \textit{/etc/postgresql/9.5/main/pg\_hba.conf} w linijce \textit{local all all peer} zamienić \textit{peer} na \textit{md5}, następnie zrestartuj serwer poleceniem\\
	\verb|#/etc/init.d/postgresql restart|
	
	\item zbudować program wraz ze środowiskiem poleceniem \verb|scons|
	
	\item wczytać bazę danych \textit{ogorek\_roboczy} poleceniem\\
	\verb|scons restore_ogorek_roboczy=1|
	
	\item zbudować główną bazę danych poleceniem \verb|scons build_db=1|
	
	\item w celu konfiguracji produkcyjnej serwera www \textit{nginx} wykonać:\\
	\verb|sudo scons build_deploy=1|\\
	Należy pamiętać aby w pliku \textit{SConstruct} ustawić odpowiednio zmienne, w szczególności \textit{WWW\_SRV\_HOST}.
	W razie błędu \textit{HTTP 400}, należy sprawdzić czy w pliku \textit{settings.py}, w zmiennej \textit{ALLOWED\_HOSTS} jest prawidłowo wpisana wartość \textit{WWW\_SRV\_HOST}.
	
	\item wygenerować nowy klucz zabezpieczeń \textit{Django} poleceniem:
	\verb|new_secret_key=1|\\
	Klucz powinien pozostać taki sam w poszczególnych wdrożeniach.
	
	\item uruchomić serwer lokalnie bądź produkcyjnie poleceniami odpowiednio:\\
	\verb|scons run=l| lub \verb|scons run=p|\\
	Jeśli serwer www nie serwuje prawidłowo plików statycznych należy sprawdzić uprawnienia dostępu do folderu \textit{static}
\end{enumerate}





